---
title: "Introduction to the SciencesPo Package"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: yes
    toc_depth: 2
    toc: yes
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Introduction to SciencesPo}
   %\VignetteEngine{knitr::rmarkdown}
    \usepackage[T1]{fontenc}
     \usepackage[utf8]{inputenc}
---
  
 The popularity of R is rapidly increasing in scientific research. R has several advantages over other programming languages: it is free, it is fairly powerful, there is an excellent user community, and it was designed with the statistical analysis of data in mind.

# Overview
The **SciencesPo** package is meant to provide functions and algorithms for analyzing political behavior data, including measures of political fragmentation and seat allocation methods. It is also intended to offer built-in functions for descriptive statistics, tests, cross-tables, and pre set publication-quality plots that will require only a minimum amount of fiddling with sizes and labels, etc. Thus, giving user an easy way of making the most of their data--usually small datasets. Although this package is available for the general public, it meets my personal needs and tastes. Yours may be different.

The development of this package began in July of 2011. I found myself spending the majority of my time manipulating the dataset and very little of my time actually analyzing the data. Then, I thought in a more efficient way of doing recurrent tasks. Since then I have diligently labored to maintain this R package for basic data manipulation, as well as exploratory analyses and plotting. The **SciencesPo** is currently hosted by the R-CRAN Foundation and distributed over the internet. You can find the package source on [Github](https://github.com/danielmarcelino/SciencesPo), and you are welcome to contribute code via pull requests, or bug reports.

The purpose of this vignette is to introduce the **SciencesPo** package and familiarize the reader with the basic functions and how they can be used to simplify data analysis. In the next section, I addressed the basic aspects of setting up the package. Following, I discuss some of the basic data manipulation functions. Next, I show some of the basic functions for creating tables and cross-tabulations. Then, I present basic functions for computing distributions. Next, I address the basic functions for computing measures of political behavior. I end by introducing several plotting functions, including themes and color palettes available. Throughout the paper, I try to keep the commentary to a minimum so the user can easily breeze through this without having to digest my witty banter.

# Learning by doing
This section introduces the basics of **SciencesPo** for conducting customary analysis; the package version I'm using is `r packageVersion("SciencesPo")`. 

**SciencesPo** loads packages as needed and assumes that they are installed. Thus, the recomended form of installing the package to ensure that all the needed packages are also installed is by using the following statement:

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
install.packages("SciencesPo", dependencies = c("Depends", "Suggests"))
```

## Loading and Unloading *SciencesPo*
```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
library("SciencesPo")

## Do things ... 

unloadNamespace("SciencesPo")
```

Whenever you load the package, it will setup its own environment, including plotting themes, summary table styles, etc. Hence, some objects may be printed or plotted differently as you would have seen before loading **SciencesPo**. The package is also operator (`%>%`) friendly, so many functions will work as expected in a chain like.

## Vignette and dataset lists
To see a list of existing vignettes, type: 
```{r echo=TRUE, message=FALSE, comment=NA}
library("SciencesPo")

vignette(package = "SciencesPo")
```

To see the collection of data included in the package, type:
```{r echo=TRUE, message=FALSE, comment=NA}
data(package = "SciencesPo")
```

## To search any topic within the package
Here are some examples that demonstrates the results of help.search(), or you can also use ?? to search for for all commands that have some strings related to the text within quotes. You can also restrict the search to a specific library as:

```{r echo=TRUE, message=FALSE, comment=NA}
help.search("D'Hondt", package = 'SciencesPo')
```

The next example searches inside all R related sites for that "string", and open the results in a web browser.

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
RSiteSearch("D'Hondt") 
```

                                   
# Exploratory data functions
In this section, a samll selection of functions for conducting exploratory analysis is presented.

## Frequency tables and cross-tables
There is a specific document covering one-way, two-way, and multiway cross-tabulations with accompanying independent tests, so the following examples will only introduce the topic. 

To describe an entire data.frame, one can simply call the `Describe` function, which will produce a summary description table with the following features: variable names, labels, factor levels, and frequencies or summary statistics. For small datasets, the output can be used as the "table one" descriptive statistics in a data analysis publication report.


```{r echo=TRUE, message=FALSE, comment=NA}
Describe(titanic) 
```


To tabulate one variable responses, simply:

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
crosstable(titanic, SURVIVED) 
```

A more performant descriptive output can be obtained with the `Freq` command, which resembles the *SPSS* output. 

```{r echo=TRUE, message=FALSE, comment=NA}
Freq(titanic, SURVIVED) 
```

To add a second variable for a cross-tabulation:

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
crosstable(titanic, SEX, CLASS) 
```


To delete table entries that are less relevant, switch it to `FALSE` and to `TRUE` otherwise. For instance, to not show column proportions, switch `column` to `FALSE`.

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
crosstable(titanic, SEX, CLASS, column = FALSE) 
```

To add a third variable:

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
crosstable(titanic, SEX, CLASS, SURVIVED) 
```
The `crosstable()` function can produce tables up to 3 variables.

## Computing Standard Error and Confidence Intervals

To demonstrate the output of these functions, below are the ages of the Presidents of the United States at the time of their inaugurations.

```{r echo=TRUE, message=FALSE, cache=TRUE}
require("SciencesPo")

pres =c(42,43,46,46,47,48,49,49,50,51,51,51,51,
        51,52,52,54,54,54,54,54,55,55,55,55,56,56,56,
        57,57,57,57,58,60,61,61,61,62,64,64,65,68,69)
```


```{r eval=FALSE, echo=TRUE, message=FALSE, cache=TRUE}
CI(pres, level=.95) # confidence interval

CI(pres, level=.95)@mean # confidence interval

SE(pres) # std. error
```


## Computing Skewness and Kurtosis of Data
These functions perform three types of skewness and kurtosis assessment to conform with the **e1071** package:

```{r eval=FALSE, echo=TRUE, message=FALSE}
require("SciencesPo")

# Type 1:
skewness(pres, type = 1)

kurtosis(pres, type = 1)

# Type 2 
skewness(pres, type = 2)

kurtosis(pres, type = 2)

# Type 3 is the default
skewness(pres)

kurtosis(pres)
```

## Computing the Average Absolute Deviation

```{r eval=FALSE, echo=TRUE, message=FALSE}
AAD(pres) 

```

## Computing Winsorized Means

```{r echo=TRUE, message=FALSE}
Winsorize(pres)
```


## Measures of data internal reliability
```{r eval=FALSE, echo=TRUE, message=FALSE}
data(alpha)

str(alpha)

# Note that a coefficient of .70 or higher is considered "acceptable" in most social science research situations.

cronbach.alpha(alpha)

```

The alpha coefficient for the four items is .839, suggesting that the items have relatively high internal consistency. 
In addition to computing the alpha coefficient of reliability, we might also want to investigate the dimensionality of the scale. We can use the factor command to do this:


```{r eval=FALSE, echo=TRUE, message=FALSE}

cor(alpha) # correlation 

factanal(alpha, factors = 1, 
         rotation="none") # varimax is the default

scores="regression"
prcomp(alpha) 
```

# Data Manipulation

## Anonymize data containing identifiable information

```{r echo=FALSE, message=FALSE}

 dt <- data.frame(
 Z = sample(LETTERS,5),
 X = sample(1:5),
 Y = sample(c("yes", "no"), 5, replace = TRUE) )
dt;

dt %>% Anonymize()

```


## Safechars

By default, R converts character columns to factors. Instead of re-reading the data using \code{stringsAsFactors=FALSE}, the \code{\link{Safechars}} function identifies which columns are currently factors, and convert them all to characters parsing the levels as strings.

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
str(iris)

iris_2 = Safechars(iris)

str(iris_2)
```


## Destring
This function converts factor variables to numeric, much like the way Stata does.
```{r echo=TRUE, message=FALSE}
require(SciencesPo)

mylevels <- c('Strongly Disagree', 
              'Disagree', 
              'Neither', 
              'Agree', 
              'Strongly Agree')

myvar <- factor(sample(mylevels[1:5], 10, replace=TRUE))
```


As we can see, this vector is un(ordered) in a "strange" way so to reflect the meaning of the levels I've attributed:
```{r echo=TRUE, message=FALSE}
unclass(myvar) # testing the order
```

By `destring` this, we should get a numeric result with the same (un)order:
```{r echo=TRUE, message=FALSE}
Destring(myvar) 
```

## `Formatted`
Simple but useful. The `Formatted` function rounds numbers to text and drops leading zeros in the process. 

```{r echo=TRUE, message=FALSE}
x <- as.double(c(0.1, 1, 10, 100, 1000, 10000))

Formatted(x) 

Formatted(x, "BRL")

p = c(0.25, 25, 50)

Formatted(p, "Perc", flag="+")

Formatted(p, "Perc", decimal.mark=",")
```


# Computing Some Statistical Tests


# Distributions 

Here are some implementation of standard statistical distributions for pedagogic use. Most of these distributions are available within the base R, however, I remaned them with more intuitive names--at least in my view.

## Normal Probability Density Function
```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
normalpdf(x=1.2, mu=0, sigma=1)
```

## Normal Cumulative Distribution
```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
normalcdf(lower=-1.96, upper=1.96, mu=0, sigma=1)
```

## Inverse Cumulative Standard Normal Distribution
```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
invnormal(area=0.35, mu=0, sigma=1)
```

## Dirichlet Distribution
The \code{rdirichlet} function will return a matrix with \code{n} rows, each containing a single random number according to the supplied alpha vector or matrix. 

```{r echo=TRUE, message=FALSE, comment=NA}
alphas <- cbind(1:4, 1, 4:1);
rdirichlet(4, alphas );
```

Consider the following pratical example of its usage:
A Brazilian face-to-face poll by Datafolha conducted on Oct 03-04 (2014) with 18,116 insterviews asking for their vote preference among  presidential candidates.

```{r echo=TRUE, message=FALSE, comment=NA}
# draw a sample from the posterior
set.seed(1234);
n <- 18116;
poll <- c(40,24,22,5,5,4) / 100 * n; # The data
mcmc <- 10000;
sim <- rdirichlet(mcmc, alpha = poll + 1);
```

After obtained 10,000 simulated values, we look at the margins of Aecio over Marina in the very last days of the campaign:
```{r echo=TRUE, message=FALSE, comment=NA}
# compute the margins: Aecio minus Marina
margins <- sim[,2] - sim[,3];

# What is the mean of the margins
# posterior mean estimate:
mean(margins); 

# posterior standard deviation:
sd(margins); 

# 90% credible interval:
quantile(margins, probs = c(0.025, 0.975)); 

# posterior probability of a positive margin (Aécio over Marina):
mean(margins > 0); 

```


```{r eval=FALSE, echo=TRUE, fig.width=4.5, fig.height=3.5, message=FALSE, comment=NA}
library(ggplot2)
g <- ggplot(data=data.frame(means=adj_means), aes(x=means))
g <- g + ggtitle("Central Limit Theorem: Samples from Exponential Distribution")
g <- g + xlab("Means from 1000 Samples (n=40)") + ylab("Density")
g <- g + geom_histogram(
    aes(y=..density..), fill="#400040", colour="#FFFFFF", binwidth=0.1
)
g <- g + geom_vline(
    aes(xintercept=mean(means), colour="Actual Mean"), size=1,
    show.legend=TRUE
)
g <- g + geom_vline(
    aes(xintercept=1/lambda, colour="Expected Mean"), size=1,
    show.legend=TRUE
)
g <- g + stat_function(fun=dnorm, args=list(mean=1/lambda),
    aes(linetype="Normal Distribution"), colour="#D0D000", size=1,
    show.legend=FALSE
)
g <- g + scale_colour_manual("Means", values=c(
    "Expected Mean" = "#8080FF",
    "Actual Mean" = "#FF8080",
    "Normal Distribution" = NA
))
g <- g + scale_linetype_manual("Functions", values=c(
    "Expected Mean" = "blank",
    "Actual Mean" = "blank",
    "Normal Distribution" = "solid"
))
g <- g + guides(
    linetype = guide_legend(
        override.aes = list(colour="#D0D000")
    )
)
g

```


## Binomial Probability Density Function

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
trials = 10
prob = c(.2,.25,.3,.35)
success = 4
binompdf(n = trials, p = prob, x = success)
```

## Binomial Cumulative Distribution Function

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
trials = 10
prob = c(.2,.25,.3,.35)
success = 4
binomcdf(n = trials, p = prob, x = success)
```


# Political Behavior Measures

## Measures of Political Diversity

```{r politicalDiversity1, echo=TRUE, message=FALSE}
library("SciencesPo")

# The 1980 presidential election in the US (vote share):

(US1980 <- c("Democratic"=0.410, "Republican"=0.507,
              "Independent"=0.066, "Libertarian"=0.011,
              "Citizens"=0.003, "Others"=0.003));

PoliticalDiversity(US1980); # ENEP (laakso/taagepera) method 

PoliticalDiversity(US1980, index= "golosov");

```

Considers the following `data.frame` with electoral results for the 1999 election in Helsinki, the seats were allocated using both the Saint-Laguë and the D'Hondt methods: 

```{r Helsinki-election, echo=TRUE, message=FALSE}
# Helsinki's 1999

Helsinki <- data.frame(
  votes = c(68885, 18343, 86448, 21982, 51587,
            27227, 8482, 7250, 365, 2734, 1925,
            475, 1693, 693, 308, 980, 560, 590, 185),
  seats.SL=c(5, 1, 6, 1, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0),
 seats.dH=c(5, 1, 7, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0))
```


```{r echo=TRUE, message=FALSE, comment=NA}
# politicalDiversity(Helsinki$votes); #ENEP Votes

PoliticalDiversity(Helsinki$seats.SL); #ENP for Saint-Lague

PoliticalDiversity(Helsinki$seats.dH); #ENP for D'Hondt
```

## Highest Averages Methods of Allocating Seats Proportionally

Now using data from 2014 Brazilian legislative elections, especifically from one district, let's compare the results from D'Hondt, Saint-Lague, Hungtinton-Hill, and Imperiali methods.

```{r Ceara-election, echo=TRUE, cache=TRUE}
# Results for the state legislative house of Ceara (2014):
Ceara <- c("PCdoB"=187906, "PDT"=326841,"PEN"=132531, "PMDB"=981096,
           "PRB"=2043217,"PSB"=15061, "PSC"=103679, "PSTU"=109830,
           "PTdoB"=213988, "PTC"=67145, "PTN"=278267)
```

The basic imputs for this class of functions are: 1) a list of parties, 2) a list of positive votes, and 3) a constant value for the number of seats to be returned. A numeric value (0~1) for the threshold is optional.

### d'Hondt

```{r highestAverages1, echo=TRUE, message=FALSE, comment=NA}
HighestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "dh") 
```

The d'Hondt method is only one way of allocating seats in party list systems. Other methods include the Saint-Lague, the modified Saint-Lague, the Danish version, Imperiali (do not to confuse with the Imperiali quota which is a Largest remainder method), and Hungtinton-Hill. 

### Saint-Lague

```{r echo=TRUE, message=FALSE, comment=NA}
HighestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "sl") 
```

### Using thresholds

Let's assume the electoral system has a 5\% vote threshold. Meaning that parties must get at least 5\% of the total unspoiled votes cast in order to participate in the distribution of seats. Parties *PCdoB*, *PTdoB*, *PEN*, *PSC*, *PSTU*, *PSB*, and *PTC* would then be elimiated from competition at the outset. If the d'Hondt method of seat allocation were employed, then party *PRB* would get 4 extra seats than otherwise, and party *PMDB* 3 additional seats.

```{r echo=TRUE, message=FALSE, comment=NA}
HighestAverages(parties=names(Ceara), votes=Ceara,
               seats = 42, method = "dh", threshold = 5/100) 
```

Other methods divide the votes by a mathematically derived quota, such as the Droop quota, the Hare quota (or Hamilton/Vinton), or the Imperiali quota, see next. 

## Largest Remainder Methods of Allocating Seats Proportionally

### Hare quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
LargestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hare") 
```

### Droop quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
LargestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "droop") 
```


## Suitable output for recycling in RMarkdown documents 

The output produced by the `highestAveragesof()` and `largestRemainders()`  functions is always a `data.frame`; therefore, it's very straightforward  to use with other aplications. For instance, I like the idea of using the output with the **knitr** package to produce publishable-quality tables, or graphs with **ggplot2**.


```{r echo=TRUE, message=FALSE, comment=NA}
mytable = HighestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

library(knitr)

kable(mytable, align=c("l","c","c"))
```



```{r echo=TRUE, message=FALSE, fig.width=4.5, fig.height=4.5, fig.align="center", fig.cap= "2014 Legislative Election in Ceara (M=42)"}

mytable = HighestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

p <- ggplot(mytable, aes(x=reorder(Party, Seats), y=Seats)) + 
  geom_bar(position="dodge", stat = "identity") +
  coord_flip() + labs(x="", y="# Seats")
p + theme_grey() 
```

## Proportionality Measures

### Rae's proportionality index 

### 's proportionality index 

### Grofman's proportionality index 

### Cox-Shugart's proportionality measure 

### 


# Plot Themes & Colors

**SciencesPo** brings in few themes and color palettes to enhance  **ggplot2** graphs or visualize the output of statistical models, but there are specialized packages like **ggthemes**, **cowplot**, and **** that can make graph decoration a lot easier.

The default **ggplot2** design has its charm, in my opinion. But, very often I don't like the gray background grid, particularly when I'm preparing academic papers because I feel it distracts from the data. For example, see this **ggplot2** visualization of the following plot:

```{r eval=TRUE}
detach("package:SciencesPo")

ggplot(mtcars, aes(mpg, disp,color=factor(carb),size=hp)) + geom_point(alpha=0.7) + labs(title="Bubble Plot") + scale_size_continuous(range = c(3,10))

qplot(1:3, 1:3)
```


```{r eval=FALSE}
set.seed(1)
test <- data.frame(
  org = rep(c("Mammals", "Cats", "Tigers", "Lions", "Cheetahs"), 3),
  level = rep(c("Animals", "Family", rep("Species", 3)), 3),
  group = rep("Cats",15),
  round = rep(c("Round1", "Round2", "Round3"),5),
  obsAvg = runif(15, 1, 4)
)

ggplot(test, aes(x = reorder(org, -as.numeric(level)), y = obsAvg, fill = level)) + 
  geom_bar(aes(alpha=round), stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("#E69F00", "#56B4E9", "#009E73")) +
  scale_alpha_manual(values = c(.5, .75, 1), guide = FALSE) + 
  labs(title = "Average Observation Score by by Round", y = "", x = "", fill = "Group") +
  theme_538() +
  geom_text(aes(label = round(obsAvg,1), group=round), vjust = -.5, size = 4, fontface="bold", position = position_dodge(width = .9)) +
  scale_y_continuous(limits = c(0,4), expand = c(0,0)) +
  theme(legend.position="bottom")

```



```{r eval=FALSE}
municipality.plot <- ggplot(y, aes(x=as.factor(year), y=seats, fill=party, color=party)) +
      geom_bar(bandwidth=1, stat="identity", group="party", position="fill") +
      labs(x="year", y="% of seats for municipality")

  year district.id                                                         party seats ideology
1  2012         127                  Stranka Pravde I Razvoja Bosne I Hercegovine     1        p
2  2012         127                                Savez Za Bolju Buducnost (SBB)     3        p
3  2008         127                              Stranka Demokratske Akcije (SDA)    13        p
4  2004         127                              Stranka Demokratske Akcije (SDA)    14        p
5  2008         127                          Hrvatska Demokratska Zajednica (HDZ)     1        c
6  2008         127                  Stranka Pravde I Razvoja Bosne I Hercegovine     1        p
7  2012         127                        Stranka Za Bosnu I Hercegovinu (SzBiH)     4        p
8  2000         127                              Socijaldemokratska Partija (SDP)     8        m
9  2012         127                     Narodna Stranka Radom Za Boljitak (NSRzB)     2        m
10 2012         127                            Socijaldemokratska Unija Bih (SDU)     1        p
11 2000         127                                         Koalicija - SDA, SBiH    15        p
12 2008         127                              Socijaldemokratska Partija (SDP)     5        m
13 2008         127                     Narodna Stranka Radom Za Boljitak (NSRzB)     1        m
14 2008         127                                          Koalicija - LDS, SDU     2        m
15 2000         127 Lgk-liberalno-gradanska Koalicija Bih (liberali Bih, Gds Bih)     1        m
16 2000         127                               Nova Hrvatska Inicijativa (NHI)     1        c
17 1997         127                              Socijaldemokratska Partija (SDP)     3        m
18 2012         127                              Socijaldemokratska Partija (SDP)     6        m
19 2004         127                        Stranka Za Bosnu I Hercegovinu (SzBiH)     5        p
20 1997         127                 Bosanskohercegovacka Patriotska Stranka (BPS)     9        p
21 2000         127                 Bosanskohercegovacka Patriotska Stranka (BPS)     3        p
22 2008         127                        Stranka Za Bosnu I Hercegovinu (SzBiH)     4        p
23 1997         127                          Hrvatska Demokratska Zajednica (HDZ)     5        c
24 2000         127                          Hrvatska Demokratska Zajednica (HDZ)     2        c
25 2012         127                              Stranka Demokratske Akcije (SDA)    10        p
26 2004         127                              Socijaldemokratska Partija (SDP)     6        m
27 1997         127                          Koalicija - SDA, SBiH, Liberali, GDS    13        p



#####################################3
# alt 2. Plot with separate legends for each ideology


# create separate plots for each ideology to get legends

# conservative parties blue
cons <- ggplot(data = df2[df2$ideology == "c", ],
               aes(x = as.factor(year),
                   y = seats,
                   fill = party)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = blue, name = "Conservative parties" )


# extract 'cons' legend
tmp <- ggplot_gtable(ggplot_build(cons))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend_cons <- tmp$grobs[[leg]]


# progressive parties green
prog <- ggplot(data = df2[df2$ideology == "p", ],
               aes(x = as.factor(year),
                   y = seats,
                   fill = party)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = green, name = "Progressive parties" )

# extract 'prog' legend
tmp <- ggplot_gtable(ggplot_build(prog))
leg <- which(sapply(tmp$grobs, function(x) x$name) ==  "guide-box")
legend_prog <- tmp$grobs[[leg]]


# moderate parties red
mod <- ggplot(data = df2[df2$ideology == "m", ],
              aes(x = as.factor(year),
                  y = seats,
                  fill = party)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = red, name = "Moderate parties" )


# extract 'mod' legend
tmp <- ggplot_gtable(ggplot_build(mod))
leg <- which(sapply(tmp$grobs, function(x) x$name) ==  "guide-box")
legend_mod <- tmp$grobs[[leg]]

#######################################


# arrange plot and legends

# define plotting regions (viewports) for plot and legends
vp_plot <- viewport(x = 0.25, y = 0.5,
                    width = 0.5, height = 1)

vp_legend_cons <- viewport(x = 0.66, y = 0.87,
                           width = 0.5, height = 0.15)

vp_legend_prog <- viewport(x = 0.7, y = 0.55,
                           width = 0.5, height = 0.60)

vp_legend_mod <- viewport(x = 0.75, y = 0.2,
                          width = 0.5, height = 0.30)

# clear current device
grid.newpage()

# add objects to the viewports
# plot without legend
print(g1 + theme(legend.position = "none"), vp = vp_plot)
upViewport(0)

# legends
pushViewport(vp_legend_cons)
grid.draw(legend_cons)
upViewport(0)

pushViewport(vp_legend_prog)
grid.draw(legend_prog)  
upViewport(0)

pushViewport(vp_legend_mod)
grid.draw(legend_mod)
```



I rather prefer a clean layout for publication. Starting with simple layouts is better because we can add things as we need rather than taking them away. Thus, by default, the `theme_pub` prints a plot without background and minor grid lines. Also, if a legend is needed, it will appear underneath of the plot rather than on the right side.

```{r eval=TRUE}
require(SciencesPo)
qplot(1:3, 1:3)
```

There's a complete discussion of plot design in the outstanding reference [Cookbook for R](http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/) that might be of your interest.

## Changing defaults 
If you want to change the theme for an entire session you can use `theme_set()` as in `theme_set(theme_gray())` to switch to default **ggplot2** theme for all subsequent plots. Otherwise, you may also apply themes without changing the default setup as of `plot + theme_gray()`. 

To modify general aspects of the `theme_pub()` as fontsize, font family etc:

```{r echo=FALSE, message=FALSE}
require(SciencesPo)

theme_set(theme_pub(base_size=12)) # default fontsize doesn't work well for online viewing
qplot(1:3, 1:3)
```


The default fontfamily used in the theme is "Helvetica", but it is easy to chane to another style:

```{r eval=FALSE, echo=FALSE, message=FALSE}
require(SciencesPo)
# "Verdana", "serif" and "sans" are also high-readability fonts
theme_set(theme_pub(base_size=12, font_family = "Consolas")) 

qplot(1:3, 1:3)
```

Modify it with theme()
```{r echo=FALSE, message=FALSE}

prefs <- theme(axis.text = element_text(size=14, colour=NULL))

qplot(1:3, 1:3) + prefs
```



```{r echo=FALSE, message=FALSE}
# Modifying a theme function
themeMod <- theme_gray() +
  theme(text = element_text(family = "Times", colour = "blue", size = 14))

ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + 
   geom_point(size = 2.5)
```


You might be able to put the legend inside the plot area, using:
  
line_plot + theme(legend.justification=c(1,0), legend.position=c(1,0))

This positions the legend inside the plot area, at the bottom-right. You can also put the legend at the top or bottom of the plot using, e.g.:
  
line_plot + theme(legend.position="bottom")


```{r echo=FALSE, message=FALSE}
# Only change the 'colour' property of theme element 'text'

mytheme1 <- theme_grey() + theme(text = element_text(colour="red"))
mytheme1$text
```


```{r echo=FALSE, message=FALSE}
# Replace the 'text' element entirely
mytheme2 <- theme_grey() %+replace% theme(text = element_text(colour="red"))
mytheme2$text
```

By default, **SciencesPo** disables grid lines on the plot. In many cases, this is the cleanest and most elegant way to display the data. However, sometimes gridlines may be useful, and thus **SciencesPo** provides a simple way of adding gridlines, via the function `background_grid()`:

```{r eval=FALSE, message=FALSE}
plot.mpg + background_grid(major = "xy", minor = "none")
```

While the same result could be obtained using the function `theme()`, the function `background_grid()` makes the most commonly used option easily accessible. See the reference documentation for details.

## Generic plot annotations

Finally, the `draw_plot()` function also allows us to place graphs at arbitrary locations and at arbitrary sizes onto the canvas. This is useful for combining subplots into a layout that is not a simple grid, e.g. with one sub-plot spanning the entire width of the figure and two other figures using up half of the figure width:

```{r eval=FALSE, message=FALSE, fig.width=7, fig.height=5}

plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + facet_grid(. ~ Species) + stat_smooth(method = "lm") +
  background_grid(major = 'y', minor = "none") + # add thin horizontal lines 
  panel_border() # and a border around each panel
# plot.mpg and plot.diamonds were defined earlier
ggdraw() +
  draw_plot(plot.iris, 0, .5, 1, .5) +
  draw_plot(plot.mpg, 0, 0, .5, .5) +
  draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), size = 15)
```


The functions `background_grid()` and `panel_border()` are convenience functions defined by **SciencesPo** to save some typing when manipulating the background grid and panel border. 

```{r eval=FALSE, echo=FALSE, message=FALSE, fig.width=7, fig.height=5}
# Of course, we can also go crazy:
ggdraw() +
  #geom_rect(data = boxes, aes(xmin = x, xmax = x + .15, ymin = y, ymax = y + .15),
  #          colour = "gray60", fill = "red", alpha=.03) +
  geom_path(data = spiral, aes(x = x, y = y, colour = t), size = 6, alpha = .4) +
  draw_plot(plot.mpg, .3, .3, .4, .4) +
  draw_plot(plot.iris, 0, .7, .7, .35 ) +
  draw_plot(plot.iris, .45, .0, .6, .3 )
```

### Annotations underneath plots

The functions `lm2eqn()` and `geom_foot()` can be of handy value for adding extra text information to a `ggplot2` object. To demonstrate its use, we need first to draw a plot: 

```{r echo=FALSE, message=FALSE, comment=NA, fig.height=3.5, fig.width=5, cache=TRUE}
theme_set(theme_pub())

# Generating a ratio winner/opponent measure 
presheights = transform(presheights, 
                       height_ratio = winner.height/opponent.height) 


p <- ggplot(presheights, aes(x=height_ratio, y=winner.vote)) +
      geom_smooth(method=lm, colour="red", fill="gold")+
      geom_point(size = 5, alpha = .7) +
      xlim(0.85,1.2) + ylim(25, 70) +
      xlab("Winner/Opponent Height Ratio") + 
      ylab("Relative Support for the Winner")
p
```

Next, we add the linear equation results and source or credits as footnote. Did you notice them?

```{r eval=FALSE, echo=TRUE, fig.height=3.5, fig.width=5,  message=FALSE, comment=NA,}
theme_set(theme_pub())
# Avoiding missing data:
presheights <- subset(presheights, !is.na(height_ratio))

fit=lm(winner.vote~height_ratio,data=presheights)

mylabel=lm2eqn("Presidents","height_ratio","winner.vote")

p + annotate(geom = 'text', x = 1.1, y = 70, size = 5,
               label = mylabel, fontface = 'italic')

geom_foot("danielmarcelino.github.io", color = fade("brown1"), 
          rotn = -90, just ="right" )
```


## Themes 

There are two basic themes in the package:

 - `theme_pub()` Produces a consistent theme for ggplot2 graphs with a white background and fewer grid lines.
 
 - `theme_fte()` Produces a consistent theme for ggplot2 graphs, similar to the plots used in the <http://fivethirtyeight.com/>.
    
 - `theme_darkside()` Produces a consistent theme for ggplot2 graphs with a dark background and fewer grid lines.
 
 - `theme_blank()` Produces a consistent theme for ggplot2 graphs with no background, axis texts, or grid lines.
  
## Color palettes

The following scales help passing manual values to scale colors for ggplot2 objects. Also, these scales allow for consistency with the themes whitin the package described earlier.

  - `scale_color_pub()`
  - `scale_fill_pub()`
  - `scale_shape_pub()`
  - `scale_color_party()`
  - `scale_fill_party()`


## Discrete palletes

```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
library("scales", quietly = TRUE)

show_col(pub_color_pal("pub12")(12))
```


```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("gray5")(6))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("carnival")(5))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("fte")(5))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("colorblind")(10))
```


```{r echo=TRUE, fig.width=5.5, fig.height=4.5}
show_col(pub_color_pal("manyeyes")(20))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("tableau20")(5))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("tableau10")(10))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("tableau10medium")(10))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("tableau10light")(10))
```


```{r echo=TRUE, fig.width=5.5, fig.height=4.5}
show_col(pub_color_pal("cyclic")(20))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("purplegray12")(12))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("greenorange12")(12))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(pub_color_pal("bluered12")(12))
```


```{r echo=TRUE, fig.width=4.5, fig.height=4.5}
show_col(party_color_pal("BRA")(10))
```


## Continuous palletes


### Bivariate scales 

```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("trafficlight")(9))
```

```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("bivariate1")(9))
```

```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("bivariate2")(9))
```

```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("bivariate3")(9))
```

```{r echo=TRUE, fig.width=4.5, fig.height=3.5}
show_col(pub_color_pal("bivariate4")(9))
```


# Session Info
```{r, echo=FALSE, message=FALSE, comment=NA}
print(sessionInfo())
```
