---
title: "Introduction to the SciencesPo Package"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Introduction to SciencesPo}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---
  
  To call in the statistician after the experiment is done may be no more than asking him to perform a post-mortem examination: he may be able to say what the experiment died of. ~ Sir Ronald Aylmer Fisher
The plural of anecdote is not data. ~ Roger Brinner
The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data. ~ John Tukey

# Overview
The **SciencesPo** package is meant to provide algorithms and functions for analyzing political behavior data, including measures of political fragmentation and seats allocation. In addition, it also offers built-in functions for descriptive statistics, tests, tables, and pre set publication-ready plots and themes for **ggplot2**, which will require only a minimum amount of fiddling with sizes and labels, etc. The package is intended to give students and postdocs an easy way of making the most of their data--usually small datasets. Although this package is available for the general public, it meets my personal needs and tastes. Yours may be different.

You can find the package source on [Github](https://github.com/danielmarcelino/SciencesPo), and you are welcome to contribute code via pull requests, or file feature requests and bug reports via [Github issues](https://github.com/danielmarcelino/SciencesPo/issues).

# Learning by doing
This vignette builds on the examples scattered through the package's manual available on [https://cran.r-project.org](https://cran.r-project.org/web/packages/SciencesPo/SciencesPo.pdf). This first example walks through setting up **SciencesPo** for conducting basic data analysis.


## Loading and Unloading *SciencesPo*
```{r echo=FALSE, message=FALSE}
library(SciencesPo)

getOption("digits")


## Do things 


detach("package:SciencesPo", unload=TRUE)


#You can also use the unloadNamespace command,

unloadNamespace("SciencesPo")

```

## Search results from help.search()
Here are some examples demonstrating the results of help.search(), or you can also use ?? to search for a string.

```{r echo=FALSE, message=FALSE}
help.search('bar.plot')


help.search('crosstabs', package = 'SciencesPo')
```

## Vignette and dataset lists

```{r echo=FALSE, message=FALSE}
vignette(package = "SciencesPo")
```


```{r echo=FALSE, message=FALSE}
data(package = "SciencesPo")
```


# Loading data much easier


## Example of printing objects
First we take a look at a quick example of printing some R objects in the R console:

Whenever you load the package, it will setup its own environment, including plotting themes. Thus, some objects may be printed differently with what you would have seen in a normal R console. To not use the default settings, one can use : 

## Exploratory data functions

### Computing the Skewness and Kurtosis of the Data
This function performs three types of skewness tests:
```{r echo=FALSE, message=FALSE}
require(SciencesPo)

set.seed(51)
 w <-sample(4,10, TRUE)
 x <- sample(10, 1000, replace=TRUE, prob=w)
 
skewness(x, type = 1);
kurtosis(x, type = 1);
skewness(x); # Type 2 is the default 
kurtosis(x); # Type 2 is the default 
skewness(x, type = 3);
kurtosis(x, type = 3);

```


### Standard Error and Confidence Interval

The Standard Error, Confidence Interval and other little, but essential functions gained S4 classes; thus each slot--or attribute is accessed using `@`, just as `$` for lists.
To demonstrate the functions output, below are the ages of the Presidents of the United States at the times of their inaugurations.

```{r echo=FALSE, message=FALSE, cache=TRUE}
pres =c(42,43,46,46,47,48,49,49,50,51,51,51,51,51,52,52,54,54,54,54,54,55,55,55,55,56,56,56,57,57,57,57,58,60,61,61,61,62,64,64,65,68,69)

ci(pres, level=.95) # confidence interval

ci(pres, level=.95)@mean # confidence interval

se(pres) # std. error
```



```{r echo=FALSE, message=FALSE}
x <- c(1, 2.3, 2, 3, 4, 8, 12, 43, -1,-4)

aad(pres) 
```


# Data Manipulation


## `safe.chars`
By default, R converts character columns to factors. Instead of re-reading the data using \code{stringsAsFactors=FALSE}, the \code{\link{safe.chars}} function identifies which columns are currently factors, and convert them all to characters parsing the levels as strings.

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
str(iris)

iris_2 = safe.chars(iris)

str(iris_2)
```


## `destring`
This function converts factor variables to numeric, much like the way Stata does.
```{r echo=FALSE, message=FALSE}
require(SciencesPo)

mylevels <- c('Strongly Disagree', 
              'Disagree', 
              'Neither', 
              'Agree', 
              'Strongly Agree')

myvar <- factor(sample(mylevels[1:5], 10, replace=TRUE))
```


As we can see, this vector is un(ordered) in a "strange" way so to reflect the meaning of the levels I've attributed:
```{r echo=FALSE, message=FALSE}
unclass(myvar) # testing the order
```

By `destring` this, we should get a numeric result with the same (un)order:
```{r echo=FALSE, message=FALSE}
destring(myvar) 
```

## `rounded`
It's rather common to use numbers without leading zeros. The `rounded` function does just that. Isn't fancy?

```{r echo=FALSE, message=FALSE}
 (x = seq(0, 1, by=.1))
 rounded(x) 
```


# Tables
There is a specific document covering one-way, two-way, and multiway tabulations with accompanying independent tests. 

To tabulate on variable's responses, simply:

```{r echo=FALSE, message=FALSE}
CrossTabs(titanic$SURVIVED) 
```

A more performant descriptive output can be obtained with the `Freq` command, which resembles the *SPSS* output. 

```{r, eval=FALSE, echo=FALSE, message=FALSE}
Freq(titanic, SURVIVED) 
```

To add a second, for a cross-tabulation:

```{r echo=FALSE, message=FALSE}
CrossTabs(titanic$SEX, titanic$SURVIVED) 
```


To delete table entries that are less relevant, for instance, to delete expected frequency, `expected=FALSE`. 

```{r echo=FALSE, message=FALSE}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE) 
```

To add table entries that relevant, add `TRUE` to it, for instance: `row=TRUE`, `column=TRUE`, `total=TRUE` etc.

```{r echo=FALSE, message=FALSE}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE, row=TRUE, column=TRUE) 
```


# The 'chisq=FALSE' argument refers to a Chi-Square test of Independence, To calculate the test, switch it to `TRUE`.
```{r echo=FALSE, message=FALSE}
CrossTabs(titanic$SEX, titanic$SURVIVED, expected=FALSE, chisq=TRUE) 
```



# Distributions 

## `uniform`


# Political Behavior Measures

One of the the first objectives of the **SciencesPo** when it was still a bunch of separate functions was to provide methods for computing many of the popular measures used in political science courses, such as indices of political concentration/fragmentation, inequality, and seat apportionment methods. The following examples demontrates how these functions work in **SciencesPo**.

## Political Diversity Indices

```{r echo=FALSE, message=FALSE}
library("SciencesPo")

# The 1980 presidential election in the US (vote share):

US1980 <- c("Democratic"=0.410, "Republican"=0.507, "Independent"=0.066, "Libertarian"=0.011, "Citizens"=0.003, "Others"=0.003)

politicalDiversity(US1980) # laakso/taagepera method

politicalDiversity(US1980, index= "golosov")

politicalDiversity(US1980, index= "herfindahl")

```

Electoral results for the 1999 election in Helsinki, with seats allocated using the Saint-Lague and the D'Hondt methods: 

```{r eval=TRUE}
# Helsinki's 1999

Helsinki <- data.frame(
votes = c(68885,18343,86448,21982,51587,27227,8482,7250,365,
2734,1925,475,1693,693,308,980,560,590,185),
seats_SL=c(5, 1, 6, 1, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
seats_DH=c(5, 1, 7, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

politicalDiversity(Helsinki$votes) #ENEP Votes

politicalDiversity(Helsinki$seats_SL) #ENP for Saint-Lague

politicalDiversity(Helsinki$seats_DH) #ENP for D'Hondt
```

## The Highest Averages Method of Allocating Seats Proportionally

Now using data from 2014 Brazilian legislative elections, especifically from one district, let's compare the results between the D'Hondt and Saint-Lague methods.

```{r eval=TRUE, cache=TRUE}
# Results for the state legislative house of Ceara (2014):
Ceara <- c("PCdoB"=187906, "PDT"=326841,"PEN"=132531, 
           "PMDB"=981096, "PRB"=2043217,"PSB"=15061,"PSC"=103679,
           "PSTU"=109830, "PTdoB"=213988, "PTC"=67145, "PTN"=278267)
```

```{r eval=FALSE}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "dh") 
```

```{r eval=TRUE}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "sl") 
```

How this one compares to the Modified Sainte-Lague version?

```{r eval=TRUE}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "msl") 
```


## Output suitable for RMarkdown documents 
Because the output of these functions is a `data.frame`, we can use `knitr` to produce more academic style tables as in the following example.

```{r eval=TRUE}
mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "msl") 

library(knitr)

kable(mytable, align=c("l","c","c"))
```



# Exploratory Statistical Tests


# Plot Design

The default **ggplot2** design has its charm, in my opinion. But, very often I don't like the gray background grid, particularly when I'm preparing academic papers because I feel it distracts from the data. For example, see this **ggplot2** visualization of the following plot:

```{r eval=TRUE}
detach("package:SciencesPo")

ggplot(mtcars, aes(mpg, disp,color=factor(carb),size=hp)) + geom_point(alpha=0.7) + labs(title="Bubble Plot") + scale_size_continuous(range = c(3,10))

qplot(1:3, 1:3)
```

I rather prefer a clean layout for publication. Starting with simple layouts is better because we can add things as we need rather than taking them away. Thus, by default, the `theme_pub` prints a plot without background and minor grid lines. Also, if a legend is needed, it will appear underneath of the plot rather than on the right side.

```{r eval=TRUE}
require(SciencesPo)
qplot(1:3, 1:3)
```

There's a complete discussion of plot design in the outstanding reference [Cookbook for R](http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/) that might be of your interest.

If you ever want to use the default **ggplot2** or some other theme while using the **SciencesPo** library, simply add the theme to your plot object, or set it as the default for all subsequent plots using the `theme_set()` command.

```{r eval=FALSE}
plot + theme_gray() # create plot with default ggplot2 theme
theme_set(theme_gray()) # switch to default ggplot2 theme
```

To modify general aspects of the `theme_pub` theme:

```{r echo=FALSE, message=FALSE}
require(SciencesPo)
theme_set(theme_pub(font_size=12)) # default fontsize doesn't work well for online viewing
qplot(1:3, 1:3)
```


The default fontfamily used in the theme is "Helvetica", but it is easy to chane to another style: 
```{r echo=FALSE, message=FALSE}
require(SciencesPo)
# "Verdana", "serif" and "sans" are also high-readability fonts
theme_set(theme_pub(font_size=12, font_family = "Consolas")) 
qplot(1:3, 1:3)
```

Modify it with theme()
```{r echo=FALSE, message=FALSE}
prefs <- theme(axis.text = element_text(size=14, colour=NULL))

qplot(1:3, 1:3) + prefs
```

```{r echo=FALSE, message=FALSE}
# Modifying a theme function
themeMod <- theme_gray() +
  theme(text = element_text(family = "Times", colour = "blue", size = 14))

ggplot(mpg, aes(x = cty, y = hwy, colour = factor(cyl))) + 
   geom_point(size = 2.5)
```


You might be able to put the legend inside the plot area, using:
  
line_plot + theme(legend.justification=c(1,0), legend.position=c(1,0))

This positions the legend inside the plot area, at the bottom-right. You can also put the legend at the top or bottom of the plot using, e.g.:
  
line_plot + theme(legend.position="bottom")

```{r echo=FALSE, message=FALSE}
# Only change the 'colour' property of theme element 'text'

mytheme1 <- theme_grey() + theme(text = element_text(colour="red"))
mytheme1$text
```


```{r echo=FALSE, message=FALSE}
# Replace the 'text' element entirely
mytheme2 <- theme_grey() %+replace% theme(text = element_text(colour="red"))
mytheme2$text
```

By default, **SciencesPo** disables grid lines on the plot. In many cases, this is the cleanest and most elegant way to display the data. However, sometimes gridlines may be useful, and thus **SciencesPo** provides a simple way of adding gridlines, via the function `background_grid()`:

```{r eval=FALSE, message=FALSE}
plot.mpg + background_grid(major = "xy", minor = "none")
```

While the same result could be obtained using the function `theme()`, the function `background_grid()` makes the most commonly used option easily accessible. See the reference documentation for details.

# Generic plot annotations

Finally, the `draw_plot()` function also allows us to place graphs at arbitrary locations and at arbitrary sizes onto the canvas. This is useful for combining subplots into a layout that is not a simple grid, e.g. with one sub-plot spanning the entire width of the figure and two other figures using up half of the figure width:

```{r eval=FALSE, message=FALSE, fig.width=7, fig.height=5}

plot.iris <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + facet_grid(. ~ Species) + stat_smooth(method = "lm") +
  background_grid(major = 'y', minor = "none") + # add thin horizontal lines 
  panel_border() # and a border around each panel
# plot.mpg and plot.diamonds were defined earlier
ggdraw() +
  draw_plot(plot.iris, 0, .5, 1, .5) +
  draw_plot(plot.mpg, 0, 0, .5, .5) +
  draw_plot_label(c("A", "B", "C"), c(0, 0, 0.5), c(1, 0.5, 0.5), size = 15)
```


The functions `background_grid()` and `panel_border()` are convenience functions defined by **SciencesPo** to save some typing when manipulating the background grid and panel border. 

```{r eval=FALSE, echo=FALSE, message=FALSE, fig.width=7, fig.height=5}
# Of course, we can also go crazy:
ggdraw() +
  #geom_rect(data = boxes, aes(xmin = x, xmax = x + .15, ymin = y, ymax = y + .15),
  #          colour = "gray60", fill = "red", alpha=.03) +
  geom_path(data = spiral, aes(x = x, y = y, colour = t), size = 6, alpha = .4) +
  draw_plot(plot.mpg, .3, .3, .4, .4) +
  draw_plot(plot.iris, 0, .7, .7, .35 ) +
  draw_plot(plot.iris, .45, .0, .6, .3 )
```

## Annotations underneath plots

The function `geom_foot()` can be used to add annotation text as a plot footnotes. To demonstrate its use, we first make a plot, adding the footnote next: 

```{r fig.width=5, fig.height=4}

# Generating a ratio winner/opponent measure 
Presidents = transform(Presidents, 
                       height_ratio = winner.height/opponent.height) 

# Avoid missing data
Presidents <- subset(Presidents, !is.na(height_ratio))


fit=lm(winner.vote~height_ratio,data=Presidents)

mylabel=lm2eqn("Presidents","height_ratio","winner.vote")

p1 <- ggplot(Presidents, aes(x=height_ratio, y=winner.vote)) +
  geom_smooth(method=lm, colour="red", fill="gold")+
  geom_point(size = 5, alpha = .7) +
annotate(geom = 'text', x = 1.15, y = 70, size = 5, label = mylabel, fontface = 'italic') +
  xlim(0.85,1.2) + ylim(25, 70) +
  xlab("Winner/Opponent Height Ratio") + 
  ylab("Relative Support for the Winner")
p1 

geom_foot("Draft Analysis, 2015", color = "magenta")

```

