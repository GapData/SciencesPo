---
title: "Block-Randomized Designs"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output: 
  #pdf_document:
   # number_sections: true
  #  toc: no
  #  toc_depth: 2
  rmarkdown::html_vignette:
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Block-Randomized Designs}
   %\VignetteEngine{knitr::rmarkdown}
    \usepackage[T1]{fontenc}
     \usepackage[utf8]{inputenc}
     %\usepackage[portuguese]{babel}
---
       > To call in the statistician after the experiment is done may be no more than asking him to perform a post-mortem examination: he may be able to say what the experiment died of. Sir R.A. Fisher (1938)

# Introduction
One important concept of experimental designs is the Randomized Block Designs (RBD). Because all experiments have counfounding factors, the experimenter will typically need to spend some time deciding which counfounding factors are important enough to keep track of or control, if possible, during the experiment. For example, in applying a treatment, nuisance factors might be the specific operator who prepared the treatment, the time of day the experiment was run, and the room temperature. 
In experimental trials, blocking is used to remove--or reduce the effects of  the most important nuisance variables. Randomization is then used to reduce the contaminating effects of the remaining counfounding variables.
The basic idea of a randomized block experiment is that the whole experiment is a collection of completely randomized experiments, each run within one of the blocks of the total experiment.

The *SciencesPo* library has a long named function which helps creating block-randomized designs. The `rbd()` function generates randomized blocks based on the number of units \code{n} and block-size, where the block-size is the number of experimental conditions. 
The number of Independent Variables (IV), as well as the number of levels in each IV are specified as input information. The output produced will be the block randomized design given the information supplied. The same design can be always replicated by using the same value in the \code{seed} parameter. Therefore, the function can very helpful in planning randomized trails.
In what follows is a short example of the function usage in the context of a randomized study.

# Example of a Randomized Block Design

Suppose engineers at a semiconductor manufacturing facility want to test whether different wafer implant material dosages have a significant effect on resistivity measurements after a diffusion process taking place in a furnace. They have four different dosages they want to try and enough experimental wafers from the same lot to run three wafers at each of the dosages.
The nuisance factor they are concerned with is "furnace run" since it is known that each furnace run differs from the last and impacts many process parameters.
An ideal way to run this experiment would be to run all the 4x3=12 wafers in the same furnace run. That would eliminate the nuisance furnace factor completely. However, regular production wafers have furnace priority, and only a few experimental wafers are allowed into any furnace run at the same time.
A non-blocked way to run this experiment would be to run each of the twelve experimental wafers, in random order, one per furnace run. That would increase the experimental error of each resistivity measurement by the run-to-run furnace variability and make it more difficult to study the effects of the different dosages. The blocked way to run this experiment, assuming you can convince manufacturing to let you put four experimental wafers in a furnace run, would be to put four wafers with different dosages in each of three furnace runs. The only randomization would be choosing which of the three wafers with dosage 1 would go into furnace run 1, and similarly for the wafers with dosages 2, 3 and 4.


```{r echo=TRUE, message=FALSE, comment=NA}
library("SciencesPo", quietly = TRUE)
```

Let X1 be dosage "level" and X2 be the blocking factor furnace run. Then the experiment can be described as follows:

With the following, we generate 
```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
blk <- rbd(blocksize = 20, n = 80, seed = 51)

head(blk)
```

k = 2 factors (1 primary factor X1 and 1 blocking factor X2) 
L1 = 4 levels of factor X1 
L2 = 3 levels of factor X2 
n = 1 replication per cell 
N =L1 * L2 = 4 * 3 = 12 runs

```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
print(blk);
```


We can make a table for aesthetic visualization:

```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
crosstable(blk, block, condition)
```

Let's generate some synthetic data and do the analysis. For simplicity, I will add the data right in the `blk` table.

```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
 set.seed(51);
 blk$y <- rnorm(n = 80, mean = 20, sd = 5)
```

Look at some descriptives:
```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
(mean = tapply(blk$y, list(blk$condition, blk$block), mean))
(sd = tapply(blk$y, list(blk$condition, blk$block), sd))
```

Do the ANOVA and make some visualization:
 
```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
fit.aov <- aov(y ~ factor(condition) + factor(block), data=blk)
summary(fit.aov) # display Type I ANOVA table
drop1(fit.aov,~.,test="F") # type III SS and F Tests

```

In the above formula, we describe the response `y` by both the treatment factor `condition` and the block control `block`. A little reminding is important here. While the `aov()` function treats `block` as a random error component of the variance, the `lm()` does as a fixed effect. So, keep this in mind.

Since a p-value of 0.254 is much greater than the .05 significance level, we cannot reject the null hypothesis that the mean of `y` for each treatment conditions are all equal.

```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
model.tables(fit.aov, "means", se=TRUE) # SE for differences, NOT for means
```

To calculate pooled standard error of the means, we can proceed as follows:
```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
pooled.se = sqrt(1688.1/4)
``` 


```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
block <- c(1,2,3,4) # the values of the x axis
Control <- mean[1,] # the results from the means output
Treat <- mean[2,] # the results from the means output
```


```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
plot(block, Treat, type = "b", ylab = "outcome", xlab = "blocks of experimental conditions", ylim = c(0, 30) )

```


```{r echo=TRUE, message=FALSE, comment=NA, cache=TRUE}
fit.lm <- lm(y ~ factor(condition) + factor(block), data = blk)
anova(fit.aov)
```
