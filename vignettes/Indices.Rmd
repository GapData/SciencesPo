---
title: "Some Political Behavior Measures"
author: "Daniel Marcelino"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Some Political Behavior Measures}
  %\VignetteEngine{knitr::rmarkdown}
    %\usepackage[utf8]{inputenc}
     %\usepackage[T1]{fontenc}

---
  
## Introduction

The very objective of the *SciencesPo* package is to provide methods for computing many of the popular measures used in political science courses, such as indices of political concentration--or fragmentation, inequality, and seat apportionment methods. The following examples demontrates how to use some of the functions available in *SciencesPo*.

## Political Diversity Indices

```{r politicalDiversity1, echo=TRUE, message=FALSE}
library("SciencesPo")

# The 1980 presidential election in the US (vote share):

(US1980 <- c("Democratic"=0.410, "Republican"=0.507,
              "Independent"=0.066, "Libertarian"=0.011,
              "Citizens"=0.003, "Others"=0.003));

politicalDiversity(US1980); # ENEP (laakso/taagepera) method 

politicalDiversity(US1980, index= "golosov");

politicalDiversity(US1980, index= "herfindahl");


```

Considers the following `data.frame` with electoral results for the 1999 election in Helsinki, the seats were allocated using both the Saint-Lague and the D'Hondt methods: 

```{r Helsinki-election, echo=TRUE, message=FALSE}
# Helsinki's 1999

Helsinki <- data.frame(votes = c(68885, 18343, 86448, 21982, 51587,
                                 27227, 8482, 7250, 365, 2734, 1925,
                                 475, 1693, 693, 308, 980, 560, 590, 185),
                       seats_SL=c(5, 1, 6, 1, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0),
                       seats_DH=c(5, 1, 7, 1, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0))
```

```{r echo=TRUE, message=FALSE, comment=NA}
# politicalDiversity(Helsinki$votes); #ENEP Votes

politicalDiversity(Helsinki$seats_SL); #ENP for Saint-Lague

politicalDiversity(Helsinki$seats_DH); #ENP for D'Hondt
```

## Highest Averages Methods of Allocating Seats Proportionally

Now using data from 2014 Brazilian legislative elections, especifically from one district, let's compare the results between the D'Hondt, Saint-Lague, and Hungtinton-Hill methods.

```{r Ceara-election, echo=TRUE, cache=TRUE}
# Results for the state legislative house of Ceara (2014):
Ceara <- c("PCdoB"=187906, "PDT"=326841,"PEN"=132531, "PMDB"=981096,
           "PRB"=2043217,"PSB"=15061, "PSC"=103679, "PSTU"=109830,
           "PTdoB"=213988, "PTC"=67145, "PTN"=278267)
```

The basic imputs for this class of functions are: 1) a list of parties, 2) a list of positive votes, and 3) a constant value for the number of seats to be returned. A numeric value (0~1) for the threshold is optional.

### d'Hondt

```{r highestAverages1, echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "dh") 
```

The d'Hondt method is only one way of allocating seats in party list systems. Other methods include the Saint-Lague, the modified Saint-Lague, the Danish version, Imperiali (do not to confuse with the Imperiali quota which is a Largest remainder method), and Hungtinton-Hill. 

### Saint-Lague

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara,
                seats = 42, method = "sl") 
```

### Modified Saint-Lague
How does the Sainte-Lague method compare to the modified Sainte-Lague one?

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "msl") 
```

### Hungtinton-Hill
How about the Hungtinton-Hill method?

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hill") 
```

### Imperiali

```{r echo=TRUE, message=FALSE, comment=NA}
highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "imperiali") 
```

### Using thresholds

Let's assume that we have an election with 1,000 total voters in which five parties (A, B, C, D, and E) have gained 100 (10\%), 150 (15\%), 300 (30\%), 400 (40\%), and 50 (5\%) votes, respectively. In this electoral constituency, there are 3 seats up for election, and all votes cast are valid; the electoral system has a 7\% vote threshold. Meaning that parties must get at least 7\% of the total unspoiled votes cast in order to participate in the distribution of seats. 
Party *E* would then be elimiated from competition at the outset. If the d'Hondt method of seat allocation were employed, then party *C* would get 1 seat (or 33\% of the number of seats), and party *D* 2 seats (or 67\% of the seats).

```{r echo=TRUE, message=FALSE, comment=NA}

const <- c("A"=100, "B"=150,"C"=300, "D"=400, "E"=50)

highestAverages(parties=names(const), votes=const,
               seats = 3, method = "dh", threshold = 7/100) 
```

Other methods divide the votes by a mathematically derived quota, such as the Droop quota, the Hare quota (or Hamilton/Vinton), or the Imperiali quota, see next. 


## Largest Remainder Methods of Allocating Seats Proportionally

### Hare quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "hare") 
```

### Droop quota

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
largestRemainders(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "droop") 
```

### Imperiali quota
 
```{r data-Italy, eval=FALSE, echo=TRUE, message=FALSE}

# The 1946 Italian Constituent Assembly election results: parties and unspoilt votes

Italy = data.frame(party=c("DC", "PSIUP", "PCI", "UDN", "UQ", "PRI",
                            "BNL", "PdA", "MIS", "PCd'I", "CDR",
                           "PSd'Az", "MUI", "PCS", "PDL", "FDPR"),
                   votes=c(8101004, 4758129, 4356686, 1560638,	1211956,
                           1003007, 637328, 334748, 171201, 102393,
                           97690, 78554, 71021, 51088, 40633, 21853))
```

```{r eval=FALSE, echo=TRUE, message=FALSE, comment=NA}
with(Italy, largestRemainders(parties=party, votes=votes, 
                seats = 556, method = "imperiali.q") )
```


### Suitable output for recycling in RMarkdown documents 

The output produced by the `highestAveragesof()` and `largestRemainders()`  functions is always a `data.frame`; therefore, it's very straightforward  to use with other aplications. For instance, I like the idea of using the output with the **knitr** package to produce publishable-quality tables, or graphs with **ggplot2**.


```{r echo=TRUE, message=FALSE, comment=NA}
mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

library(knitr)

kable(mytable, align=c("l","c","c"))
```



```{r echo=TRUE, message=FALSE, fig.width=4.5, fig.height=4.5, fig.align="center", fig.cap= "2014 Legislative Election in Ceara (M=42)"}

mytable = highestAverages(parties=names(Ceara), votes=Ceara, 
                seats = 42, method = "dh") 

p <- ggplot(mytable, aes(x=reorder(Party, Seats), y=Seats)) + 
  geom_bar( position="dodge", stat = "identity") +
  coord_flip() + labs(x="", y="# Seats")

p + theme_grey() 
```

